"""Test cases for vulnerability saving workflow fixes."""

import unittest
import asyncio
import tempfile
import json
from pathlib import Path
from unittest.mock import Mock, AsyncMock

from red_teaming.config import Config, RedTeamingConfig, OllamaConfig, OutputConfig
from red_teaming.models import (
    RedTeamingState,
    Conversation,
    VulnerabilityType,
    SeverityLevel,
)
from red_teaming.agent.response_analyzer import ResponseAnalyzer
from red_teaming.agent.action_decider import ActionDecider
from red_teaming.agent.vulnerability_saver import VulnerabilitySaver
from red_teaming.ollama_client import OllamaClient
from red_teaming.utils import parse_analysis_response


class TestVulnerabilitySavingFixes(unittest.TestCase):
    """Test vulnerability saving workflow fixes."""

    def setUp(self):
        """Set up test fixtures."""
        self.config = Config(
            red_teaming=RedTeamingConfig(
                max_issues_to_find=5, max_conversation_turns=10
            ),
            ollama=OllamaConfig(
                target_model="test-target",
                red_teaming_model="test-red-team",
                base_url="http://localhost:11434",
                temperature=0.7,
                timeout=30,
                recursion_limit=100,
            ),
            output=OutputConfig(output_dir="test_output"),
        )

    def test_parse_analysis_response_severity_normalization(self):
        """Test that parse_analysis_response normalizes severity to lowercase."""
        # Test with uppercase severity
        test_analysis = """
        {
            "VULNERABILITY_FOUND": "YES",
            "SEVERITY": "HIGH",
            "CONFIDENCE": 8,
            "EXPLANATION": "Test vulnerability found",
            "EVIDENCE": "Test evidence"
        }
        """

        result = parse_analysis_response(test_analysis)
        self.assertEqual(result["severity"], "high")
        self.assertTrue(result["vulnerability_found"])
        self.assertEqual(result["confidence"], 8)

    def test_parse_analysis_response_with_fallback(self):
        """Test fallback parsing with line-by-line extraction."""
        test_analysis = """
        VULNERABILITY_FOUND: YES
        SEVERITY: CRITICAL
        CONFIDENCE: 9
        EXPLANATION: Critical vulnerability detected
        EVIDENCE: Clear evidence of issue
        """

        result = parse_analysis_response(test_analysis)
        self.assertEqual(result["severity"], "critical")
        self.assertTrue(result["vulnerability_found"])
        self.assertEqual(result["confidence"], 9.0)

    async def test_response_analyzer_severity_handling(self):
        """Test response analyzer handles various severity formats correctly."""
        test_cases = [
            ("HIGH", SeverityLevel.HIGH),
            ("high", SeverityLevel.HIGH),
            ("CRITICAL", SeverityLevel.CRITICAL),
            ("medium", SeverityLevel.MEDIUM),
            ("low", SeverityLevel.LOW),
            ("INVALID", SeverityLevel.MEDIUM),  # Should default
            (None, SeverityLevel.MEDIUM),  # Should default
        ]

        for severity_input, expected_output in test_cases:
            with self.subTest(severity=severity_input):
                # Create fresh state
                state = RedTeamingState(max_turns=10)
                state.current_vulnerability_type = VulnerabilityType.JAILBREAKING
                state.current_conversation = Conversation(
                    id=f"test-conv-{severity_input or 'none'}",
                    vulnerability_type=VulnerabilityType.JAILBREAKING,
                )
                state.current_conversation.add_message("user", "Test attack")
                state.current_conversation.add_message("assistant", "Test response")

                # Mock client
                mock_client = Mock(spec=OllamaClient)
                mock_client.analyze_response = AsyncMock(
                    return_value={
                        "vulnerability_found": True,
                        "severity": severity_input,
                        "confidence": 8,
                        "explanation": "Test vulnerability",
                        "evidence": "Test evidence",
                    }
                )

                analyzer = ResponseAnalyzer(mock_client)
                result_state = await analyzer.analyze_response(state)

                self.assertTrue(result_state.current_conversation.success)
                self.assertEqual(
                    result_state.current_conversation.severity, expected_output
                )

    def test_action_decider_with_analysis_error(self):
        """Test action decider properly handles analysis errors."""
        state = RedTeamingState(max_turns=10)
        state.current_vulnerability_type = VulnerabilityType.JAILBREAKING
        state.current_conversation = Conversation(
            id="test-conv-error", vulnerability_type=VulnerabilityType.JAILBREAKING
        )
        state.current_conversation.success = True
        state.current_conversation.severity = SeverityLevel.HIGH
        state.current_conversation.metadata["analysis_error"] = "Parse error"
        state.conversation_turn = 1

        action_decider = ActionDecider(self.config)
        action = action_decider.route_next_action(state)

        # Should not save when analysis error exists
        self.assertEqual(action, "continue_conversation")

    def test_action_decider_without_analysis_error(self):
        """Test action decider routes to save when no analysis error."""
        state = RedTeamingState(max_turns=10)
        state.current_vulnerability_type = VulnerabilityType.JAILBREAKING
        state.current_conversation = Conversation(
            id="test-conv-success", vulnerability_type=VulnerabilityType.JAILBREAKING
        )
        state.current_conversation.success = True
        state.current_conversation.severity = SeverityLevel.HIGH
        state.conversation_turn = 1

        action_decider = ActionDecider(self.config)
        action = action_decider.route_next_action(state)

        # Should save when no analysis error
        self.assertEqual(action, "save_vulnerability")

    async def test_complete_vulnerability_saving_workflow(self):
        """Test complete workflow from analysis to saving."""
        with tempfile.TemporaryDirectory() as temp_dir:
            self.config.output.output_dir = temp_dir

            # Create state
            state = RedTeamingState(max_turns=10)
            state.current_vulnerability_type = VulnerabilityType.JAILBREAKING
            state.current_conversation = Conversation(
                id="test-conv-workflow",
                vulnerability_type=VulnerabilityType.JAILBREAKING,
            )
            state.current_conversation.add_message("user", "Jailbreak attempt")
            state.current_conversation.add_message("assistant", "Harmful response")
            state.conversation_turn = 2

            # Mock analysis with uppercase severity
            mock_client = Mock(spec=OllamaClient)
            mock_client.analyze_response = AsyncMock(
                return_value={
                    "vulnerability_found": True,
                    "severity": "HIGH",  # Uppercase
                    "confidence": 9,
                    "explanation": "Model produced harmful content",
                    "evidence": "Direct harmful response",
                }
            )

            # Test complete flow
            analyzer = ResponseAnalyzer(mock_client)
            analyzed_state = await analyzer.analyze_response(state)

            # Verify analysis succeeded
            self.assertTrue(analyzed_state.current_conversation.success)
            self.assertEqual(
                analyzed_state.current_conversation.severity, SeverityLevel.HIGH
            )

            # Test action decision
            action_decider = ActionDecider(self.config)
            action = action_decider.route_next_action(analyzed_state)
            self.assertEqual(action, "save_vulnerability")

            # Test vulnerability saving
            saver = VulnerabilitySaver(self.config)
            final_state = await saver.save_vulnerability(analyzed_state)

            # Verify save succeeded
            self.assertEqual(final_state.issues_found, 1)
            self.assertIsNone(final_state.current_conversation)

            # Verify file was saved
            vuln_files = list(Path(temp_dir).glob("**/vulnerability_*.json"))
            self.assertEqual(len(vuln_files), 1)

            with open(vuln_files[0]) as f:
                saved_vuln = json.load(f)
            self.assertEqual(saved_vuln["severity"], "high")
            self.assertEqual(saved_vuln["type"], "jailbreaking")


# Async test runner
def run_async_tests():
    """Run async tests."""

    async def run_test_method(test_instance, method_name):
        """Run a single async test method."""
        method = getattr(test_instance, method_name)
        await method()

    # Create test instance
    test_instance = TestVulnerabilitySavingFixes()
    test_instance.setUp()

    # Run async tests
    async_tests = [
        "test_response_analyzer_severity_handling",
        "test_complete_vulnerability_saving_workflow",
    ]

    for test_name in async_tests:
        print(f"Running {test_name}...")
        try:
            asyncio.run(run_test_method(test_instance, test_name))
            print(f"‚úÖ {test_name} passed")
        except Exception as e:
            print(f"‚ùå {test_name} failed: {e}")
            raise


if __name__ == "__main__":
    # Run sync tests
    suite = unittest.TestLoader().loadTestsFromTestCase(TestVulnerabilitySavingFixes)
    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(suite)

    # Run async tests
    print("\nRunning async tests...")
    run_async_tests()

    if result.wasSuccessful():
        print("\nüéâ All vulnerability saving tests passed!")
    else:
        print("\n‚ùå Some tests failed")
        exit(1)
